# -*- coding: utf-8 -*-
"""transformer_pytorch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12UayfqWQjofQbxSzkLngczwDiWTGz2R3

https://github.com/ndb796/Deep-Learning-Paper-Review-and-Practice/blob/master/code_practices/Attention_is_All_You_Need_Tutorial_(German_English).ipynb

https://tutorials.pytorch.kr/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py   

https://github.com/graykode/nlp-tutorial/blob/master/5-1.Transformer/Transformer.ipynb

https://github.com/jadore801120/attention-is-all-you-need-pytorch/tree/master/transformer
"""

# BLEU Score 계산 라이브러리
pip install torchtext==0.6.0

"""### Data Preprocessing 
- spacy library : tokenization, tagging   

영어(Engilsh)와 독일어(Deutsch) 전처리 모듈 설치
"""

# Commented out IPython magic to ensure Python compatibility.
# #https://ipython.readthedocs.io/en/stable/interactive/magics.html#cellmagic-capture
# # 밑에 나오는 내용 억제 
# %%capture   
# python -m spacy download en
# python -m spacy download de

import spacy

spacy_en = spacy.load('en') # 영어 토큰화(tokenization)
spacy_de = spacy.load('de') # 독일어 토큰화(tokenization)

# 독일어(Deutsch) 문장을 토큰화 하는 함수 (순서를 뒤집지 않음)
def tokenize_de(text):
    return [token.text for token in spacy_de.tokenizer(text)]

# 영어(English) 문장을 토큰화 하는 함수
def tokenize_en(text):
    return [token.text for token in spacy_en.tokenizer(text)]

from torchtext.data import Field, BucketIterator

SRC = Field(tokenize=tokenize_de, init_token="<sos>", eos_token="<eos>", lower=True, batch_first=True)
TRG = Field(tokenize=tokenize_en, init_token="<sos>", eos_token="<eos>", lower=True, batch_first=True)

"""전처리부터 """

# 영어-독어 번역 데이터셋 Milti30k
from torchtext.datasets import Multi30k

train_dataset, valid_dataset, test_dataset = Multi30k.splits(exts=(".de", ".en"), fields = (SRC, TRG))

# #https://torchtext.readthedocs.io/en/latest/datasets.html#wmt14
# #http://pytorch.org/text/master/experimental_datasets.html#wmt14
# from torchtext.datasets import WMT14

# train_data, valid_data, test_data = WMT14.splits(exts=(".de", ".en"), fields=(SRC, TRG))

#field 객체의 build_vocab 메서드를 이용해 영어, 독어의 단어 사전을 생성 
# 최소 2번 이상 등장한 단어만 선택
SRC.build_vocab(train_dataset, min_freq=2)
TRG.build_vocab(train_dataset, min_freq=2)

print(f"len(SRC): {len(SRC.vocab)}")
print(f"len(TRG): {len(TRG.vocab)}")

"""- 한 문장에 포함된 단어가 순서대로 나열된 상태로 네트워크에 입력되어야 합니다.
1. 따라서 하나의 배치에 포함된 문장들이 가지는 단어의 개수가 유사하도록 만들면 좋습니다.
2. 이를 위해 BucketIterator를 사용합니다.
3. 배치 크기(batch size): 128
"""

import torch

device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu') 

BATCH_SIZE = 128

# bucketIterator 가변길이 정해줌
train_iterator, valid_iterator, test_iterator = BucketIterator.splits(
    (train_dataset, valid_dataset, test_dataset),
    batch_size = BATCH_SIZE,
    device = device)

for i, batch in enumerate(train_iterator):
    src = batch.src
    trg = batch.trg

    print(f"첫 번째 배치 크기: {src.shape}")

    # 현재 배치에 있는 하나의 문장에 포함된 정보 출력
    for i in range(src.shape[1]):
        print(f"인덱스 {i}: {src[0][i].item()}") # 여기에서는 [Seq_num, Seq_len]

    # 첫 번째 배치만 확인
    break

import torch
import numpy as np
import torch.nn as nn
import torch.nn.functional as F

"""# Transformer : Model archetecture

### MultiHeadAttention
d_k = d_v = d_q = d_model/h 

- hyperparameter
1. hidden_dim: 하나의 단어에 대한 emb_dim
2. n_heads = h = 헤드의 개수
3. dropout_ratio : 정규화 테크닉 dropout 비율 : 0.1(논문)

"""

class MultiHeadAttentionLayer(nn.Module):
  def __init__(self, hidden_dim, n_heads, dropout_ratio, device):
    super().__init__()

    assert hidden_dim % n_heads == 0

    self.hidden_dim = hidden_dim #임베딩 차원
    self.n_heads = n_heads # scaledotproduct attn 의 h개수
    self.head_dim = hidden_dim // n_heads 

    self.fc_q = nn.Linear(hidden_dim, hidden_dim) #Query 값에 적용될 FC 레이어
    self.fc_k = nn.Linear(hidden_dim, hidden_dim)
    self.fc_v = nn.Linear(hidden_dim, hidden_dim)

    self.fc_o = nn.Linear(hidden_dim, hidden_dim)

    self.dropout = nn.Dropout(dropout_ratio)

    self.scale = torch.sqrt(torch.FloatTensor([self.head_dim])).to(device)

  def forward(self, query, key, value, mask = None):

    batch_size = query.shape[0]

    # querry : [batch_size, query_len, hidden_dim]

    Q = self.fc_q(query)
    K = self.fc_k(key)
    V = self.fc_v(value)

    # hidden_dim -> n_heads x head_dim 
    # n_heads 개의 서로 다른 어텐션 학습 
    Q = Q.view(batch_size, -1, self.n_heads, self.head_dim).permute(0, 2, 1, 3)
    K = K.view(batch_size, -1, self.n_heads, self.head_dim).permute(0, 2, 1, 3)
    V = V.view(batch_size, -1, self.n_heads, self.head_dim).permute(0, 2, 1, 3)

    # Q : [batch_size, n_heads, querry_len, head_dim]  view, permute로 변경

    #-------------------------------------------------------------------------
    #attention energy : matmul / scale
    energy = torch.matmul(Q, K.permute(0, 1, 3, 2)) / self.scale

    # energy : [batch_size, n_heads, querry_len, key_len]

    #마스크(mask)
    if mask is not None:
      #마스크 값이 0인부분을 -1e10으로 채움
      energy = energy.masked_fill(mask==0, -1e10)

    #attn score : softmax 
    attention = torch.softmax(energy, dim  = -1)

    #softmax -> matmul : scaled Dot-product attn output
    x = torch.matmul(self.dropout(attention), V)

    #------------------------------------------------------------------------
    x = x.permute(0, 2, 1, 3).contiguous() 
    
    #concat : view를 통해 펴준다 
    x = x.view(batch_size, -1, self.hidden_dim)

    x = self.fc_o(x)  # 마지막 Linear 거침
    
    #x x : [batch_size, querry_len, hidden_dim]

    return x, attention  # 시각화를 위해 attetion도 return

# class ScaledDotProductAttention(nn.Module):
#   def __init__(self):
#     super(ScaledDotProductAttention, self).__init__()

#   def forward(self, q, k, v, mask):
#     scores = torch.matmul(q, k.transpose(-1, -2))/ np.sqrt(d_k)
#     scores.masked_fill_(attn_mask, -1e9)

#     attn = nn.Softmax(dim=-1)(scores)
#     output = torch.matmul(attn, v)

#     return output, attn

# import torch.nn as nn

# class MutiHeadAttention(nn.Module):
#   def __init__(self, n_head, d_model, d_k, d_v, dropout = 0.1):
#     super().__init__()

#     self.n_head = n_head # 헤드(head)의 개수
#     self.d_k = d_k
#     self.d_v = d_v

#     self.W_Q = nn.Linear(d_model, d_k * n_heads)
#     self.W_K = nn.Linear(d_model, d_k * n_heads)
#     self.W_V = nn.Linear(d_model, d_v * n_heads)
#     self.linear = nn.Linear(n_heads * d_v, d_model)

#     self.dropout = nn.dropout(dropout)
#     self.layer_norm = nn.LayerNorm(d_model)

#   def forward(self, q, k, v, mask):
#     residual, batch_size = q, q.size(0)

#     #dot product 하기 위해 Transpose
#     q_s = self.W_Q(q).view(batch_size, -1, n_heads, d_k).transpose(1,2)  
#     k_s = self.W_K(k).view(batch_size, -1, n_heads, d_k).transpose(1,2)  
#     v_s = self.W_V(v).view(batch_size, -1, n_heads, d_v).transpose(1,2)   

#     if mask is not None:
#       mask = mask.unsqueeze(1) # 특정 위치에 1인 차원 추가

#     q, attn = ScaledDotProductAttention()(q_s, k_s, v_s, mask)
#     q = q.transpose(1, 2).contiguous().view(batch_size, -1, n_heads * d_v)
#     q = self.linear(q)

#     return q, attn

"""### Positionwisefeedforward
d_in = d_model =512   
d_hid = d_ff = 2028

relu 함수 사용
"""

class PositionwiseFeedForwardLayer(nn.Module):
  def __init__(self, hidden_dim, pf_dim, dropout_ratio):
    super().__init__()

    self.fc_1 = nn.Linear(hidden_dim, pf_dim)
    self.fc_2 = nn.Linear(pf_dim, hidden_dim) #입력과 출력의 차원 동일 = hidden_dim

    self.dropout = nn.Dropout(dropout_ratio)

  def forward(self, x):
    x = self.dropout(torch.relu(self.fc_1(x)))

    x = self.fc_2(x)

    return x

# class PositionwiseFeedForward(nn.Module):
#   def __init__(self, d_in, d_hid, dropout=0.1):
#       super().__init__()
#       self.w_1 = nn.Linear(d_in, d_hid) # position-wise
#       self.w_2 = nn.Linear(d_hid, d_in) # position-wise
#       self.layer_norm = nn.LayerNorm(d_in, eps=1e-6)
#       self.dropout = nn.Dropout(dropout)

#   def forward(self, x):

#       residual = x

#       x = self.w_2(F.relu(self.w_1(x)))
#       x = self.dropout(x)
#       x += residual

#       x = self.layer_norm(x)

#       return x

"""# Encoder
- EncoderLayer가 여러 번 중첩되어 인코더로 들어간다.


"""

class EncoderLayer(nn.Module):
  def __init__(self, hidden_dim, n_heads, pf_dim, dropout_ratio, device):
    super().__init__()

    # self_attn + layer_norm 
    # feed_forward + layer_norm
    self.self_attn_layer_norm = nn.LayerNorm(hidden_dim)
    self.ff_layer_norm = nn.LayerNorm(hidden_dim)   
    self.self_attention = MultiHeadAttentionLayer(hidden_dim, n_heads, dropout_ratio, device)
    self.positionwise_feedforward = PositionwiseFeedForwardLayer(hidden_dim, pf_dim, dropout_ratio)
    self.dropout = nn.Dropout(dropout_ratio)

    #하나의 임베딩된 단어(src)가 복제되어 Querry, Key, Value로 입력 
  def forward(self, src, src_mask):

    #self attention : 필요할 때 mask 행렬 사용 -> 단어 조절 기능
    _src, _ = self.self_attention(src, src, src, src_mask)

    #dropout, residual connection and layer norm
    src = self.self_attn_layer_norm(src + self.dropout(_src))

    #postion-wise feedforward
    _src = self.positionwise_feedforward(src)

    #dropout, residual connection and layer norm
    src = self.ff_layer_norm(src + self.dropout(_src))

    return src

"""- EncoderLayer을 여러 개 쌓는다.
- positional embedding을 학습하는 형태로 구현 
- BERT에서 쓰는 방식 

- positional embedding도 구현 해본다
"""

class Encoder(nn.Module):
  def __init__(self, input_dim, hidden_dim, n_layers, n_heads, pf_dim, dropout_ratio, device, max_length=100):
    super().__init__()

    self.device = device

    self.tok_embedding = nn.Embedding(input_dim, hidden_dim)
    self.pos_embedding = nn.Embedding(max_length, hidden_dim)

    # ModuleList 이용해 n_layers만큼 반복할 수 있게 쌓음
    self.layers = nn.ModuleList([EncoderLayer(hidden_dim, n_heads, pf_dim, dropout_ratio, device) for _ in range(n_layers)])
    self.dropout = nn.Dropout(dropout_ratio)
    self.scale = torch.sqrt(torch.FloatTensor([hidden_dim])).to(device)

  def forward(self, src, src_mask):

    batch_size = src.shape[0]
    src_len = src.shape[1]

    pos = torch.arange(0, src_len).unsqueeze(0).repeat(batch_size, 1).to(self.device)

    # token embedding 에 scaling  +  position_embedding 
    src = self.dropout((self.tok_embedding(src) * self.scale) + self.pos_embedding(pos))

    for layer in self.layers:
      src = layer(src, src_mask) # 순차적으로 진행 : output은 마지막 layer에서 
      
    return src #마지막 레이어의 출력

# class EncoderLayer(nn.Module):
#   def __init__(self):
#     super(EncoderLayer, self).__init__()
#     self.enc_self_attn = MutiHeadAttention()
#     self.posff = PositionwiseFeedForward()
  
#   def forward(self, enc_input, enc_self_attn_mask):
#       enc_output, attn = self.enc_self_attn(enc_input, enc_input, enc_input, enc_self_attn_mask) 
#       enc_output = self.pos_ffn(enc_output) # enc_outputs: [batch_size x len_q x d_model]
      
#       return enc_output, attn

# class Encoder(nn.Module):
#   def __init__(self):
#       super(Encoder, self).__init__()
#       self.src_emb = nn.Embedding(src_vocab_size, d_model)
#       self.pos_emb = nn.Embedding.from_pretrained(get_sinusoid_encoding_table(src_len+1, d_model),freeze=True)
#       self.layers = nn.ModuleList([EncoderLayer() for _ in range(n_layers)])

#   def forward(self, enc_input): # enc_inputs : [batch_size x source_len]
#       enc_output = self.src_emb(enc_inputs) + self.pos_emb(torch.LongTensor([[1,2,3,4,0]]))
#       enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs)
#       enc_self_attn = []
#       for layer in self.layers:
#           enc_output, enc_self_attn = layer(enc_outputs, enc_self_attn_mask)
#           enc_self_attns.append(enc_self_attn)
          
#       return enc_output, enc_self_attn

"""### Decoder
- self attention
- enc attention : encoder의 출력을 받는 attention layer 
"""

class DecoderLayer(nn.Module):
  def __init__(self, hidden_dim, n_heads, pf_dim, dropout_ratio, device):
    super().__init__()

    self.self_attn_layer_norm = nn.LayerNorm(hidden_dim)
    self.enc_attn_layer_norm = nn.LayerNorm(hidden_dim) # encoder 출력을 받는 attn layer
    self.ff_layer_norm = nn.LayerNorm(hidden_dim)   
    self.self_attention = MultiHeadAttentionLayer(hidden_dim, n_heads, dropout_ratio, device)
    self.encoder_attention = MultiHeadAttentionLayer(hidden_dim, n_heads, dropout_ratio, device)                                                  
    self.positionwise_feedforward = PositionwiseFeedForwardLayer(hidden_dim, pf_dim, dropout_ratio)
    self.dropout = nn.Dropout(dropout_ratio)

  def forward(self, trg, enc_src, trg_mask, src_mask):

    #self_attn
    _trg, _ = self.self_attention(trg, trg, trg, trg_mask)
    trg = self.self_attn_layer_norm(trg + self.dropout(_trg))

    #encoder_attn
    _trg, attention = self.encoder_attention(trg, enc_src, enc_src, src_mask)
    trg = self.enc_attn_layer_norm(trg + self.dropout(_trg))

    #positionwise ff
    _trg = self.positionwise_feedforward(trg)
    trg = self.ff_layer_norm(trg + self.dropout(_trg))

    return trg, attention

class Decoder(nn.Module):
  def __init__(self, output_dim, hidden_dim, n_layers, n_heads, pf_dim, dropout_ratio, device, max_length = 100):
    super().__init__()

    self.device = device

    self.tok_embedding = nn.Embedding(output_dim, hidden_dim)
    self.pos_embedding = nn.Embedding(max_length, hidden_dim)

    # ModuleList 이용해 n_layers만큼 반복할 수 있게 쌓음
    self.layers = nn.ModuleList([DecoderLayer(hidden_dim, n_heads, pf_dim, dropout_ratio, device) for _ in range(n_layers)])
    self.fc_out = nn.Linear(hidden_dim, output_dim)
    self.dropout = nn.Dropout(dropout_ratio)
    self.scale = torch.sqrt(torch.FloatTensor([hidden_dim])).to(device)

  def forward(self, trg, enc_src, trg_mask, src_mask):

    batch_size = trg.shape[0]
    trg_len = trg.shape[1]

    pos = torch.arange(0, trg_len).unsqueeze(0).repeat(batch_size, 1).to(self.device)

    trg = self.dropout((self.tok_embedding(trg) * self.scale) + self.pos_embedding(pos)) 

    for layer in self.layers:
      trg, attention = layer(trg, enc_src, trg_mask, src_mask)

    output = self.fc_out(trg)   

    return output, attention

# class DecoderLayer(nn.Module):
#   def __init__(self):
#     super(DecoderLayer, self).__init__()
#     self.dec_self_attn = MutiHeadAttention()
#     self.dec_enc_attn = MultiHeadAttention()
#     self.pos_ffn = PositionwiseFeedForward()

#   def forward(self, dec_input, enc_output, dec_self_attn_mask, dec_enc_attn_maks):
#     dec_output, dec_self_attn = self.dec_self_attn(dec_input, dec_input, dec_input, dec_self_attn_mask)
    
#     dec_output, dec_enc_attn = self.dec_enc_attn(dec_output, enc_output, enc_output, dec_enc_attn_mask)

#     dec_output = self.pos_ffn(dec_output)
#     return dec_output, dec_self_attn, dec_enc_attn

# class Decoder(nn.Module):
#   def __init__(self):
#     super(Decoder, self).__init__()
#     self.tgt_emb = nn.Embedding(tgt_vocab_size, d_model)
#     self.pos_emb = nn.Embedding.from_pretrained(get_sinusoid_encoding_table(tgt_len+1, d_model), freeze=True)
#     self.layers = nn.ModuleList([DecoderLayer() for _ in range(n_layers)])

#   def forward(self, dec_input, enc_input, enc_output):
#     dec_output = self.tgt_emb(dec_input) +self.pos_emb(torch.LongTensor([5,1,2,3,4]))
#     dec_self_attn_pad_mask = get_attn_pad_mask(dec_input, dec_input)
#     dec_self_attn_subsequent_mask = get_attn_subsequent_mask(dec_input)
#     dec_self_attn_mask = torch.gt((dec_self_attn_pad_mask + dec_self_attn_subsequent_mask), 0)

#     dec_enc_attn_mask = get_attn_pad_mask(dec_input, enc_input)

#     dec_self_attns, dec_enc_attns = [], []
#     for layer in self.layers:
#       dec_output, dec_self_attn, dec_enc_attn = layer(dec_output, enc_output, dec_self_attn_mask, dec_enc_attn_mask)
#       dec_self_attns.append(dec_self_attn)
#       dec_enc_attns.append(dec_enc_attn)
    
#     return dec_output, dec_self_attn, dec_enc_attn

"""### Transformer 조립"""

class Transformer(nn.Module):
  def __init__(self, encoder, decoder, src_pad_idx, trg_pad_idx, device):
    super().__init__()

    self.encoder = encoder
    self.decoder = decoder
    self.src_pad_idx = src_pad_idx
    self.trg_pad_idx = trg_pad_idx
    self.device = device
#--------------------------------------------------------------------------------
    # 문장의 <pad>토큰에 대하여 마스크 값을 0으로 설정
  def make_src_mask(self, src):

    src_mask = (src != self.src_pad_idx).unsqueeze(1).unsqueeze(2)

    return src_mask
    
    #타겟 문장에서 다음 단어 알 수 없도록 마스크
  def make_trg_mask(self, trg):

    trg_pad_mask = (trg != self.trg_pad_idx).unsqueeze(1).unsqueeze(2)

    trg_len = trg.shape[1]

    trg_sub_mask = torch.tril(torch.ones((trg_len, trg_len), device = self.device)).bool()

    trg_mask = trg_pad_mask & trg_sub_mask
      
    return trg_mask
#--------------------------------------------------------------------------------
  def forward(self, src, trg):
    src_mask = self.make_src_mask(src)
    trg_mask = self.make_trg_mask(trg)

    enc_src = self.encoder(src, src_mask)

    output, attention = self.decoder(trg, enc_src, trg_mask, src_mask)

    return output, attention

"""## Training"""

# HyperParameter
INPUT_DIM = len(SRC.vocab)
OUTPUT_DIM = len(TRG.vocab)
HIDDEN_DIM = 256
ENC_LAYERS = 3
DEC_LAYERS = 3
ENC_HEADS = 8
DEC_HEADS = 8
ENC_PF_DIM = 512
DEC_PF_DIM = 512
ENC_DROPOUT = 0.1
DEC_DROPOUT = 0.1

SRC_PAD_IDX = SRC.vocab.stoi[SRC.pad_token]
TRG_PAD_IDX = TRG.vocab.stoi[TRG.pad_token]

#인코더 디코더 객체 선언
enc = Encoder(INPUT_DIM, HIDDEN_DIM, ENC_LAYERS, ENC_HEADS, ENC_PF_DIM, ENC_DROPOUT, device)
dec = Decoder(OUTPUT_DIM, HIDDEN_DIM, ENC_LAYERS, ENC_HEADS, ENC_PF_DIM, DEC_DROPOUT, device)

#transformer 객체 선언
model = Transformer(enc, dec, SRC_PAD_IDX, TRG_PAD_IDX, device).to(device)

"""## DATA PARALLEL
[pytorch tutorial](https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html#create-model-and-dataparallel)
"""

import torch
import torch.nn as nn

if torch.cuda.device_count() > 1:
  print("Let's use", torch.cuda.device_count(), "GPUs!")
  # dim = 0 [30, xxx] -> [10, ...], [10, ...], [10, ...] on 3 GPUs
  model = nn.DataParallel(model)

model.to(device)

# 모델 가중치 파라미터 초기화
def count_parameters(model):
  return sum(p.numel() for p in model.parameters() if p.requires_grad)

print(f'The model has {count_parameters(model):,} trainable parameters')

def initialize_weights(m):
  if hasattr(m, 'weight') and m.weight.dim() > 1:
    nn.init.xavier_uniform_(m.weight)

model.apply(initialize_weights)

"""### Optimizer
- torch.optim 
"""

import torch.optim as optim

#Adam
LEARNING_RATE = 0.0005
optimizer = torch.optim.Adam(model.parameters(), lr= LEARNING_RATE)

# 뒤의 padding에 대해서는 값 무시
criterion = nn.CrossEntropyLoss(ignore_index = TRG_PAD_IDX)

# 모델 학습(train) 함수
def train(model, iterator, optimizer, criterion, clip):
    model.train() # 학습 모드
    epoch_loss = 0

    # 전체 학습 데이터
    for i, batch in enumerate(iterator):
        src = batch.src
        trg = batch.trg

        optimizer.zero_grad()

        # 출력 단어의 마지막 인덱스(<eos>)는 제외
        # 입력을 할 때는 <sos>부터 시작하도록 처리
        output, _ = model(src, trg[:, :-1])

        output_dim = output.shape[-1]

        output = output.contiguous().view(-1, output_dim)
        # 출력 단어의 인덱스 0(<sos>)은 제외
        trg = trg[:,1:].contiguous().view(-1)

        # 모델의 출력 결과와 타겟 문장을 비교하여 손실 계산
        loss = criterion(output, trg)
        loss.backward() #gradient 계산

        # gradient clipping 진행
        torch.nn.utils.clip_grad_norm_(model.parameters(), clip)

        # 파라미터 업데이트
        optimizer.step()

        # 전체 손실 값 
        epoch_loss += loss.item()

    return epoch_loss / len(iterator)

print(1)

# 모델 평가 함수 
def evaluate(model, iterator, criterion):
  model.eval()
  epoch_loss = 0 

  with torch.no_grad():
    for i, batch in enumerate(iterator):
      src = batch.src
      trg = batch.trg

      optimizer.zero_grad()

      #eos는 제외 
      output, _ = model(src, trg[:,:-1])

      output_dim = output.shape[-1]

      output = output.contiguous().view(-1, output_dim)
      trg = trg[:,1:].contiguous().view(-1)

      #결과와 target 비교 
      loss = criterion(output, trg)

      epoch_loss += loss.item()

  return epoch_loss / len(iterator)

"""### 학습"""

import math
import time

def epoch_time(start_time, end_time):
    elapsed_time = end_time - start_time
    elapsed_mins = int(elapsed_time / 60)
    elapsed_secs = int(elapsed_time - (elapsed_mins * 60))
    return elapsed_mins, elapsed_secs

import time
import math
import random

N_EPOCHS = 10
CLIP = 1
best_valid_loss = float('inf')

for epoch in range(N_EPOCHS):
  start_time = time.time()
  train_loss = train(model, train_iterator, optimizer, criterion, CLIP)
  print(1)
  valid_loss = evaluate(model, valid_iterator, criterion)

  end_time = time.time()
  epoch_mins, epoch_secs = epoch_time(start_time, end_time)

  if valid_loss < best_valid_loss: # 손실이 가장 낮은 값으로 갱신
    best_valid_loss = best_valid_loss 
    print("Outside: input size", src.size(),
          "output_size", trg.size())
    torch.save(model.state_dict(), 'transformer_german_to_english.pt')

  print(f'Epoch: {epoch + 1:02} Time: {epoch_mins}m {epoch_secs}s')
  print(f'\tTrain Loss: {train_loss:.3f} | Train PPL: {math.exp(train_loss):.3f}')
  print(f'\tValidation Loss: {valid_loss:.3f} | Validation PPL: {math.exp(valid_loss):.3f}')

#학습된 모델 저장
from google.colab import files

files.download('transformer_german_to_english.pt')

wget https://postechackr-my.sharepoint.com/:u:/g/personal/dongbinna_postech_ac_kr/EbWFiKBmscFBrbzCQxRyqwsBwcXgdKdimkdsBl2dE9VYaQ?download=1 -O transformer_german_to_english.pt

"""- Loss
- Perplexity(PPL) 
"""

model.load_state_dict(torch.load('transformer_german_to_english.pt'))

test_loss = evaluate(model, test_iterator, criterion)

print(f'Test Loss: {test_loss:.3f} | Test PPL: {math.exp(test_loss):.3f}')

# 번역(translation) 함수
def translate_sentence(sentence, src_field, trg_field, model, device, max_len=50, logging=True):
    model.eval() # 평가 모드

    if isinstance(sentence, str):
        nlp = spacy.load('de')
        tokens = [token.text.lower() for token in nlp(sentence)]
    else:
        tokens = [token.lower() for token in sentence]

    # 처음에 <sos> 토큰, 마지막에 <eos> 토큰 붙이기
    tokens = [src_field.init_token] + tokens + [src_field.eos_token]
    if logging:
        print(f"전체 소스 토큰: {tokens}")

    src_indexes = [src_field.vocab.stoi[token] for token in tokens]
    if logging:
        print(f"소스 문장 인덱스: {src_indexes}")

    src_tensor = torch.LongTensor(src_indexes).unsqueeze(0).to(device)

    # 소스 문장에 따른 마스크 생성
    src_mask = model.make_src_mask(src_tensor)

    # 인코더(endocer)에 소스 문장을 넣어 출력 값 구하기
    with torch.no_grad():
        enc_src = model.encoder(src_tensor, src_mask)

    # 처음에는 <sos> 토큰 하나만 가지고 있도록 하기
    trg_indexes = [trg_field.vocab.stoi[trg_field.init_token]]

    for i in range(max_len):
        trg_tensor = torch.LongTensor(trg_indexes).unsqueeze(0).to(device)

        # 출력 문장에 따른 마스크 생성
        trg_mask = model.make_trg_mask(trg_tensor)

        with torch.no_grad():
            output, attention = model.decoder(trg_tensor, enc_src, trg_mask, src_mask)

        # 출력 문장에서 가장 마지막 단어만 사용
        pred_token = output.argmax(2)[:,-1].item()
        trg_indexes.append(pred_token) # 출력 문장에 더하기

        # <eos>를 만나는 순간 끝
        if pred_token == trg_field.vocab.stoi[trg_field.eos_token]:
            break

    # 각 출력 단어 인덱스를 실제 단어로 변환
    trg_tokens = [trg_field.vocab.itos[i] for i in trg_indexes]

    # 첫 번째 <sos>는 제외하고 출력 문장 반환
    return trg_tokens[1:], attention

example_idx = 10

src = vars(test_dataset.examples[example_idx])['src']
trg = vars(test_dataset.examples[example_idx])['trg']

print(f'소스 문장: {src}')
print(f'타겟 문장: {trg}')

translation, attention = translate_sentence(src, SRC, TRG, model, device, logging=True)

print("모델 출력 결과:", " ".join(translation))

"""- 어텐션 맵 시각화"""

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

def display_attention(sentence, translation, attention, n_heads=8, n_rows=4, n_cols=2):

    assert n_rows * n_cols == n_heads

    # 출력할 그림 크기 조절
    fig = plt.figure(figsize=(15, 25))

    for i in range(n_heads):
        ax = fig.add_subplot(n_rows, n_cols, i + 1)

        # 어텐션(Attention) 스코어 확률 값을 이용해 그리기
        _attention = attention.squeeze(0)[i].cpu().detach().numpy()

        cax = ax.matshow(_attention, cmap='bone')

        ax.tick_params(labelsize=12)
        ax.set_xticklabels([''] + ['<sos>'] + [t.lower() for t in sentence] + ['<eos>'], rotation=45)
        ax.set_yticklabels([''] + translation)

        ax.xaxis.set_major_locator(ticker.MultipleLocator(1))
        ax.yaxis.set_major_locator(ticker.MultipleLocator(1))

    plt.show()
    plt.close()

example_idx = 10

src = vars(test_dataset.examples[example_idx])['src']
trg = vars(test_dataset.examples[example_idx])['trg']

print(f'소스 문장: {src}')
print(f'타겟 문장: {trg}')

translation, attention = translate_sentence(src, SRC, TRG, model, device, logging=True)

print("모델 출력 결과:", " ".join(translation))

display_attention(src, translation, attention)

"""- BLEU Score """

from torchtext.data.metrics import bleu_score

def show_bleu(data, src_field, trg_field, model, device, max_len=50):
    trgs = []
    pred_trgs = []
    index = 0

    for datum in data:
        src = vars(datum)['src']
        trg = vars(datum)['trg']

        pred_trg, _ = translate_sentence(src, src_field, trg_field, model, device, max_len, logging=False)

        # 마지막 <eos> 토큰 제거
        pred_trg = pred_trg[:-1]

        pred_trgs.append(pred_trg)
        trgs.append([trg])

        index += 1
        if (index + 1) % 100 == 0:
            print(f"[{index + 1}/{len(data)}]")
            print(f"예측: {pred_trg}")
            print(f"정답: {trg}")

    bleu = bleu_score(pred_trgs, trgs, max_n=4, weights=[0.25, 0.25, 0.25, 0.25])
    print(f'Total BLEU Score = {bleu*100:.2f}')

    individual_bleu1_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[1, 0, 0, 0])
    individual_bleu2_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[0, 1, 0, 0])
    individual_bleu3_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[0, 0, 1, 0])
    individual_bleu4_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[0, 0, 0, 1])

    print(f'Individual BLEU1 score = {individual_bleu1_score*100:.2f}') 
    print(f'Individual BLEU2 score = {individual_bleu2_score*100:.2f}') 
    print(f'Individual BLEU3 score = {individual_bleu3_score*100:.2f}') 
    print(f'Individual BLEU4 score = {individual_bleu4_score*100:.2f}') 

    cumulative_bleu1_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[1, 0, 0, 0])
    cumulative_bleu2_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[1/2, 1/2, 0, 0])
    cumulative_bleu3_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[1/3, 1/3, 1/3, 0])
    cumulative_bleu4_score = bleu_score(pred_trgs, trgs, max_n=4, weights=[1/4, 1/4, 1/4, 1/4])

    print(f'Cumulative BLEU1 score = {cumulative_bleu1_score*100:.2f}') 
    print(f'Cumulative BLEU2 score = {cumulative_bleu2_score*100:.2f}') 
    print(f'Cumulative BLEU3 score = {cumulative_bleu3_score*100:.2f}') 
    print(f'Cumulative BLEU4 score = {cumulative_bleu4_score*100:.2f}')

show_bleu(test_dataset, SRC, TRG, model, device)

